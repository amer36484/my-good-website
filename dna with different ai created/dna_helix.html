<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D DNA Helix — Rotating</title>
  <style>
    html,body{height:100%;margin:0;background:#05060a;color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    .wrap{display:flex;align-items:center;justify-content:center;height:100%;}
    canvas{display:block;max-width:100%;height:100vh;width:100vw}
    .ui{position:absolute;left:16px;top:16px;z-index:10;background:rgba(0,0,0,0.35);backdrop-filter:blur(6px);padding:10px;border-radius:8px;font-size:13px}
    .ui label{display:flex;gap:8px;align-items:center}
    .ui input[type=range]{width:180px}
    footer{position:fixed;right:12px;bottom:12px;color:#9aa2b3;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c"></canvas>
  </div>
  <div class="ui" aria-hidden>
    <label>Speed <input id="speed" type="range" min="0.1" max="3" step="0.05" value="1"></label>
    <label>Radius <input id="radius" type="range" min="30" max="220" step="1" value="110"></label>
    <label>Segments <input id="segments" type="range" min="12" max="200" step="1" value="80"></label>
  </div>
  <footer>3D-looking DNA helix — rotating vertically</footer>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    const DPR = Math.max(1, window.devicePixelRatio || 1);
    let W = 0, H = 0, CX = 0, CY = 0;

    const gui = {
      speed: document.getElementById('speed'),
      radius: document.getElementById('radius'),
      segments: document.getElementById('segments')
    };

    // Move lerp function above its first use
    const lerp = (a,b,t)=> a + (b-a)*t;

    let settings = {
      speed: parseFloat(gui.speed.value),
      radius: parseFloat(gui.radius.value),
      segments: parseInt(gui.segments.value),
      strandOffset: Math.PI,
      helixTurns: 3,
      dotSize: 4,
      fov: 900,
      camZ: 600
    };

    let basePoints = [];

    function resize(){
      W = innerWidth; H = innerHeight; CX = W/2; CY = H/2;
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
      basePoints = makeHelixPoints(settings.segments);
    }
    addEventListener('resize', resize);
    resize();

    gui.speed.addEventListener('input', ()=> settings.speed = parseFloat(gui.speed.value));
    gui.radius.addEventListener('input', ()=> settings.radius = parseFloat(gui.radius.value));
    gui.segments.addEventListener('input', ()=> {
      settings.segments = parseInt(gui.segments.value);
      basePoints = makeHelixPoints(settings.segments);
    });

    function makeHelixPoints(segments){
      const pts = [];
      if(segments < 2) segments = 2;
      for(let i=0;i<segments;i++){
        const t = i / (segments-1);
        const y = lerp(-H*0.45, H*0.45, t);
        const angleBase = t * settings.helixTurns * Math.PI * 2;
        pts.push({t,y,angleBase});
      }
      return pts;
    }

    let time = 0;
    function render(dt){
      if(!settings || !basePoints || basePoints.length===0) return;
      time += dt * 0.001 * settings.speed;

      ctx.clearRect(0,0,W,H);

      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'#0b0c11');
      g.addColorStop(1,'#020206');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

      const rotation = time * 0.5;
      const drawItems = [];
      const segments = settings.segments;

      for(let i=0;i<segments;i++){
        const p = basePoints[i];
        if(!p) continue;
        const ang = p.angleBase + time * 2.0;

        const xA = Math.cos(ang) * settings.radius;
        const zA = Math.sin(ang) * settings.radius;
        const yA = p.y;

        const angB = ang + settings.strandOffset;
        const xB = Math.cos(angB) * settings.radius;
        const zB = Math.sin(angB) * settings.radius;
        const yB = p.y;

        const cosR = Math.cos(rotation), sinR = Math.sin(rotation);
        const rxA = xA * cosR + zA * sinR;
        const rzA = -xA * sinR + zA * cosR;
        const rxB = xB * cosR + zB * sinR;
        const rzB = -xB * sinR + zB * cosR;

        const projA = project(rxA, yA, rzA + settings.camZ);
        const projB = project(rxB, yB, rzB + settings.camZ);

        const depthScale = clamp( (projA.s + projB.s) * 0.5, 0.2, 1.6 );

        drawItems.push({type:'rung', a:projA, b:projB, depth:(projA.z+projB.z)/2, scale:depthScale, idx:i});
        drawItems.push({type:'dot', p:projA, depth:projA.z, scale:projA.s, strand:0, idx:i});
        drawItems.push({type:'dot', p:projB, depth:projB.z, scale:projB.s, strand:1, idx:i});
      }

      drawItems.sort((A,B)=> A.depth - B.depth);

      for(const item of drawItems){
        if(item.type==='rung') drawRung(item);
        else drawDot(item);
      }

      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0,0,W,H);
      ctx.globalCompositeOperation = 'source-over';
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

    function project(x,y,z){
      const s = settings.fov / (settings.fov + z - settings.camZ/2);
      return {x: CX + x * s, y: CY + y * s, s: s, z: z};
    }

    function drawRung(item){
      const a = item.a, b = item.b;
      const t = item.idx / (settings.segments-1);
      const alpha = clamp( (item.scale-0.3) * 1.2, 0.08, 0.95) * (0.6 + 0.4*t);
      const width = clamp(1.2 * item.scale, 0.6, 5);
      const color = gradientColor(t);

      ctx.lineWidth = width;
      ctx.strokeStyle = `rgba(${color.r},${color.g},${color.b},${alpha})`;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc((a.x+b.x)/2, (a.y+b.y)/2, Math.max(0.8, 1.8*item.scale), 0, Math.PI*2);
      ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${alpha*0.08})`;
      ctx.fill();
    }

    function drawDot(item){
      const p = item.p;
      const t = item.idx / (settings.segments-1);
      const color = gradientColor(t, item.strand);
      const radius = Math.max(1.2, settings.dotSize * item.scale * (item.strand===0?0.9:1.05));
      const alpha = clamp((item.scale-0.2)*1.3, 0.04, 1) * (item.strand===0?0.95:0.9);

      ctx.beginPath();
      ctx.arc(p.x + item.scale*2.2, p.y + item.scale*2.2, radius*1.1, 0, Math.PI*2);
      ctx.fillStyle = `rgba(0,0,0,${0.18*alpha})`;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
      ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${alpha})`;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.x - radius*0.35, p.y - radius*0.45, Math.max(0.3, radius*0.45), 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255,${0.18*alpha})`;
      ctx.fill();
    }

    function gradientColor(t, strand=0){
      const h = lerp(190,320, t);
      const s = strand===0?73:85;
      const l = lerp(55,40, t);
      return hslToRgb(h/360, s/100, l/100);
    }

    function hslToRgb(h,s,l){
      var r,g,b;
      if(s==0){r=g=b=l;}
      else{
        function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}
        var q = l<0.5?l*(1+s):l+s-l*s;
        var p = 2*l-q;
        r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3);
      }
      return {r:Math.round(r*255),g:Math.round(g*255),b:Math.round(b*255)};
    }

    let last = performance.now();
    function frame(now){
      const dt = now - last; last = now;
      render(dt);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    (function ambientTweaks(){
      const startTime = Date.now();
      function tick(){
        const s = 1 + Math.sin((Date.now()-startTime)/3700) * 0.06;
        settings.radius = parseFloat(gui.radius.value) * s;
        requestAnimationFrame(tick);
      }
      tick();
    })();
  </script>
</body>
</html>
